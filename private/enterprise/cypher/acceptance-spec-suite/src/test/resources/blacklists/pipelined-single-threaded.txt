Feature "AggregationAcceptance": Scenario "Using a optional match after aggregation and before an aggregation"
Feature "AggregationAcceptance": Scenario "percentileDisc on empty data should return null"
Feature "CaseExpression": Scenario "Returning a CASE expression into integer"
Feature "CaseExpression": Scenario "Returning a CASE expression into pattern expression"
Feature "CaseExpression": Scenario "Returning a CASE expression with a pattern expression alternative"
Feature "CaseExpression": Scenario "Returning a CASE expression with label predicates"
Feature "CaseExpression": Scenario "Shorthand case with filtering pattern comprehension should work as expected"
Feature "CaseExpression": Scenario "Using a CASE expression in a WHERE, with label predicate"
Feature "CaseExpression": Scenario "Using a CASE expression in a WITH, negative case"
Feature "CaseExpression": Scenario "Using a CASE expression in a WITH, positive case"
Feature "CaseExpression": Scenario "Using a CASE expression with label predicates in a WITH"
Feature "ConstraintAcceptance": Scenario "Failing when creation would violate constraint"
Feature "ConstraintAcceptance": Scenario "Merge node with prop and label and unique index when no match"
Feature "ConstraintAcceptance": Scenario "Merge node with prop and label and unique index"
Feature "ConstraintAcceptance": Scenario "Merge using unique constraint should create missing node"
Feature "ConstraintAcceptance": Scenario "Merge using unique constraint should update existing node"
Feature "ConstraintAcceptance": Scenario "Merge with uniqueness constraints must properly handle multiple labels"
Feature "ConstraintAcceptance": Scenario "Should create on merge using multiple unique indexes and labels if found no nodes"
Feature "ConstraintAcceptance": Scenario "Should create on merge using multiple unique indexes if found no nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes and labels if found different nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if found different nodes"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if it found a node matching single property only flipped order"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes if it found a node matching single property only"
Feature "ConstraintAcceptance": Scenario "Should fail on merge using multiple unique indexes using same key if found different nodes"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes and labels if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Should match on merge using multiple unique indexes using same key if only found single node for both indexes"
Feature "ConstraintAcceptance": Scenario "Unrelated nodes with same property should not clash"
Feature "ConstraintAcceptance": Scenario "Works fine with index and constraint"
Feature "ConstraintAcceptance": Scenario "Works with property in map that gets set"
Feature "ConstraintAcceptance": Scenario "Works with property repeated in literal map in set"
Feature "Create": Scenario "Dependencies in creating multiple nodes"
Feature "Create": Scenario "Dependencies in creating multiple rels"
Feature "DeleteAcceptance": Scenario "Return properties from deleted node"
Feature "ForeachAcceptance": Scenario "Add labels inside FOREACH"
Feature "ForeachAcceptance": Scenario "Inside nested FOREACH"
Feature "ForeachAcceptance": Scenario "Inside nested FOREACH, nodes inlined"
Feature "ForeachAcceptance": Scenario "Merge inside foreach should see variables introduced by update actions outside foreach"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using a previously matched node and a previously merged node"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using a previously matched node"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using two previously merged nodes that also depend on WITH"
Feature "ForeachAcceptance": Scenario "Merging inside a FOREACH using two previously merged nodes"
Feature "ForeachAcceptance": Scenario "Should handle running merge inside a foreach loop"
Feature "IndexAcceptance": Scenario "Merge with an index must properly handle multiple labels"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and STARTS WITH predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and equality predicates"
Feature "IndexAcceptance": Scenario "Should allow AND and OR with index and inequality predicates"
Feature "IndexAcceptance": Scenario "Should allow OR with index and incoming scope to OPTIONAL"
Feature "IndexAcceptance": Scenario "Should allow OR with index and incoming scope"
Feature "IndexAcceptance": Scenario "Should be able to merge using property from match with index"
Feature "IndexAcceptance": Scenario "Works fine with index"
Feature "IndexAcceptance": Scenario "Works with indexed and unindexed property"
Feature "IndexAcceptance": Scenario "Works with two indexed properties"
Feature "MatchAcceptance": Scenario "Filter with AND/OR"
Feature "MatchAcceptance": Scenario "difficult to plan query number 1"
Feature "MatchAcceptance": Scenario "difficult to plan query number 2"
Feature "MatchAcceptance": Scenario "difficult to plan query number 3"
Feature "MergeLegacyAcceptance": Scenario "Introduce named paths"
Feature "MergeLegacyAcceptance": Scenario "Unbound pattern"
Feature "MergeLegacyAcceptance": Scenario "Using a longer pattern"
Feature "MergeLegacyAcceptance": Scenario "Using a single bound node"
Feature "MergeLegacyAcceptance": Scenario "Using bound nodes in mid-pattern when pattern partly matches"
Feature "MergeLegacyAcceptance": Scenario "Using bound nodes in mid-pattern"
Feature "OptionalMatchAcceptance": Scenario "optional match with distinct"
Feature "PatternExpressionAcceptance": Scenario "Aggregating on pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehension with food"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 2"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 3"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions 4"
Feature "PatternExpressionAcceptance": Scenario "Nested pattern comprehensions"
Feature "PatternExpressionAcceptance": Scenario "Pattern expression inside list comprehension"
Feature "PatternExpressionAcceptance": Scenario "Pattern expressions and ORDER BY"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression with bound nodes"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression with label predicate"
Feature "PatternExpressionAcceptance": Scenario "Returning a pattern expression"
Feature "PatternExpressionAcceptance": Scenario "Returning list comprehension"
Feature "PatternExpressionAcceptance": Scenario "Using a pattern expression and a CASE expression in a WHERE"
Feature "PatternExpressionAcceptance": Scenario "Using a pattern expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using a variable-length pattern expression in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using list comprehension in a WHERE"
Feature "PatternExpressionAcceptance": Scenario "Using list comprehension in a WITH"
Feature "PatternExpressionAcceptance": Scenario "Using pattern expression in RETURN"
Feature "PatternPredicates": Scenario "Filter relationships with properties using pattern predicate"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between an expression and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one expression and a negated subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, a subquery, and an equality expression"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, two subqueries, and an equality expression 2"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one negated subquery, two subqueries, and an equality expression"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between one subquery and a negated subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between two expressions and a subquery"
Feature "PatternPredicates": Scenario "Filter using a pattern predicate that is a logical OR between two subqueries"
Feature "PatternPredicates": Scenario "Filter using a variable length relationship pattern predicate with properties"
Feature "PatternPredicates": Scenario "Filter using negated pattern predicate"
Feature "PatternPredicates": Scenario "Handling pattern predicates without matches"
Feature "PatternPredicates": Scenario "Handling pattern predicates"
Feature "PatternPredicates": Scenario "Matching with complex composite pattern predicate"
Feature "PatternPredicates": Scenario "Pattern predicate should uphold the relationship uniqueness constraint"
Feature "PatternPredicates": Scenario "Returning a relationship from a pattern predicate"
Feature "PatternPredicates": Scenario "Undirected NOOP path predicate 1"
Feature "PatternPredicates": Scenario "Undirected NOOP path predicate 2"
Feature "ReturnAcceptance": Scenario "LIMIT 0 should stop side effects"
Feature "ShortestPathAcceptance": Scenario "Find a combination of a shortest path and a pattern expression"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate on all relationships"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path among paths that fulfill a predicate"
Feature "ShortestPathAcceptance": Scenario "Find a shortest path without loosing context information at runtime"
Feature "SkipLimitAcceptance": Scenario "Floating point parameter for SKIP should fail"
Feature "SkipLimitAcceptance": Scenario "Negative parameter for SKIP and an empty graph should fail"
Feature "SkipLimitAcceptance": Scenario "Negative parameter for SKIP should fail"
Feature "SkipLimitAcceptance": Scenario "Reduce SKIP should be allowed"
Feature "SkipLimitAcceptance": Scenario "Skipping more than Integer.Max rows should be allowed"
Feature "SubqueryAcceptance": Scenario "Aggregating top and bottom results"
Feature "SubqueryAcceptance": Scenario "CALL around union query - using returned var in outer query"
Feature "SubqueryAcceptance": Scenario "CALL around union query with different return column orders - using returned vars in outer query"
Feature "SubqueryAcceptance": Scenario "Aggregating top and bottom results from correlated subquery"
Feature "SubqueryAcceptance": Scenario "Aggregating top and bottom results within correlated subquery"
Feature "SubqueryAcceptance": Scenario "Aggregation on imported variables"
Feature "SubqueryAcceptance": Scenario "Grouping and aggregating within correlated subquery"
Feature "SubqueryAcceptance": Scenario "Sorting in a subquery"
Feature "UnwindAcceptance": Scenario "Pattern comprehension in unwind with empty db"
Feature "UnwindAcceptance": Scenario "Pattern comprehension in unwind with hits"
